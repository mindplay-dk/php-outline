Outline comes with a simple caching engine, which you can use to optimize the performance of your web site drastically.

Here's an example:

{{{
function show_my_template($use_this_title) {
	$_outline = new Outline('test');
	$_outline->cache();
	if ($_outline->cached(60)) {
		require $_outline->get();
	} else {
		$data = array("1", "2", "3");
		$_outline->capture();
		require $_outline->get();
		$_outline->stop();
	}
}
}}}

As in the previous example, the first thing we do, is create an instance of Outline for your template.

Next, we enable caching by calling the cache() method.

Do not confuse the cache() and cached() methods - the cache() method enables caching, while the cached() method is used to find out if the cache is valid.

In this example, cached(60) tells us whether the cached content is older than 60 seconds. (Note that, if you don't supply an argument when testing, the default value is OUTLINE_CACHE_TIME, which should be defined in your "config.php" file...)

If the the content is cached, all we have to do is 'require' the cached content - the get() method provides us with the path.

If the content is outdated, we first assign the variables we want to use in the template (in this example just $data). Then, we call the capture() method to start capturing the output of the template, and then finally the stop() method to store the captured content.

The captured content is stored in a flat text-file under the cache folder - the filename, in this example, is simply "test.html".

== Advanced (multi-level) caching ==

Caching can be done hierachically, which is a pretty powerful feature that can be used to great advantage on larger sites.

The cache() method optionally takes any number of parameters, specifying where in the cache hierachy you want to store content.

Let's say you have a site that produces a product-list on multiple pages, as well as individual detailed product pages.

When rendering a page of the product-list, you can do something like this:

{{{
$pagenum = $_GET['pagenum'];
...
$_outline->cache('product', 'list', $pagenum);
...
}}}

By default (with no arguments for the cache() method), the cached content is stored in the cache folder as "{templatename}.html" - but now instead, you get the following cache files:

	- product/list/1.html
	- product/list/2.html
	- etc.

Similarly, for your individual product pages, you can do this:

{{{
	$productid = $_GET['productid'];
	...
	$_outline->cache('product', 'detail', $productid);
	...
}}}

This gives you another folder with files like these:

	- product/detail/123.html
	- product/detail/456.html
	- etc.

By organizing your cached content in this manner, manually clearing cached content becomes extremely simple.

For example, if one product number 123 is updated with a new description, to expire the product's detail page, do this:

{{{
	$productid = 123; // (get your updated product id from somewhere)
	OutlineCache::expire('product', 'detail', $productid);
}}}

If a new product is added, the product list pages will most likely all change - to expire all the list pages, do this:

{{{
	OutlineCache::expire('product', 'list');
}}}

This clears all cached content under the product/list folder.

And finally - if you just imported a whole new database of products for some reason, to expire all product lists and all detail pages:

{{{
	OutlineCache::expire('product');
}}}

This clears all the contents of the product folder, including both the detail pages and list pages.

== Notes about caching ==

In some template engines, such as Smarty, you have a special tag that gives the template author control over caching - in Smarty, this tag is called `{insert}`.

There is nothing similar in Outline. Caching is a technical aspect of web-development, and shouldn't be controlled by the designer.

For large web applications, caching should be the responsibility of, for example, a block-based Content Management System - in which the block management system keeps track of which blocks are cacheable and not, for how long, and so on.

Most minor applications don't need caching in the first place - the caching done by the database engine, combined with bytecode caching on most hosted PHP platforms, is more than sufficient to ensure high performance.

Don't try to cache everything. If you're designing a CMS or some other block-based page system, for example, don't cache the main template - it's usually very low-complexity anyway; it probably consists mostly of the static HTML surrounding blocks of content, and just assembles the output of various (possibly cached) "blocks", banner ads, and so on.

Chances are, the overhead of the caching engine is greater than the small amount of overhead from processing your compiled main template, which essentially is just a very simple PHP script.