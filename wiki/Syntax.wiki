== Template Syntax ==

Simple conditional blocks can be implemented using if-blocks:

	`{if $var == 42} ... {elseif $var == 21} ... {else} ... {/if}`

You have your basic for-loops, which work in both directions:

	`{for $var from 1 to 20} ... {/for}`

	`{for $var from 10 to 0} ... {/for}`

You can also specify an increment, to achieve sequences like 0, 10, 20, 30 ...

	`{for $var from 0 to 100 step 10} ... {/for}`

Looping through each element of an array is similar to php:

	`{foreach $array as $var} ... {/foreach}`

Or when looping through an associative array:

	`{foreach $array as $index => $var} ... {foreach}`

Additionally, you can use {else} with the {foreach} command to execute a default action, if the foreach'ed $array is empty:

	`{foreach $array as $var} ... {else} ... {/foreach}`

You have your while-loops:

	`{while $var < 20} ... {/while}`

And you can escape from template-syntax, when you need the `{` and `}` chars for something else, e.g. inline javascript or css:

	`{ignore} ... javascript or css ... {/ignore}`

You can insert comments into your templates:

	`{* this won't be displayed or have any effect whatsoever *}`

You can of course output simple variables and define()'d php constants:

	`{$var} ... simply outputs the contents of $var`

	`{#NAME} ... outputs the contents of a defined constant, NAME`

And you can apply modifiers to them - using a syntax similar to Smarty:

	`{$var|strtoupper} ... prints $var in uppercase`

	`{#NAME|strtoupper} ... prints value of constant NAME in uppercase`
		
	`{$var|md5} ... prints the md5-sum of $var`

	`{$var|ucfirst} ... first letter in uppercase`

	`{$var|wordwrap:30:"\n"|strtolower}`

Note that any available (internal or user) php-function can be used as a modifier. It is also possible to override php-functions with template-specific modifier functions.

You can set variables, evaluate complex expressions, etc.:

	`{set $text = 'some text'}`

	`{set $number++}`

	`{set $total = $total + $price}`

	etc.

You can capture a section of the template's output to a variable:

	`{capture $myvar} ... {$myvar}`

Inside loops, you can alternate between values:

	`{cycle} value 1 {next} value 2 {next} value 3 ... {/cycle}`

You can include subtemplates:

	`{include some_template}`

	`{include $var}`

You can include and display textfiles:

	`{display myfile.ext}`

And you can include php-scripts:

	`{require myscript.php}`

== Modifiers ==

You can declare your own modifiers. Simply write standard PHP functions, or (better) prefix your function name with "`outline_`" - these functions will take presedent over non-prefixed functions, which means you can override standard pfp-functions with custom modifiers.

A few standard modifiers are included:

	`{$var|replace:"find":"replace"}`
	
	replaces "find" with "replace" - avoid php's standard str_replace() function, as it expects the string to operate on to come last.
		
	`{$var|default:"empty"}`
		
	outputs "empty" instead of null, "" (empty string) or 0 (zero).
		
	`{$var|wed}`

	`{$var|wed:50}`
		
	prevents orphans by replacing the last space with "&nbsp;". in rendered HTML, this prevents single hanging words, which is considered bad typography. the optional number, is the maximum length of the last word - if longer than that, no change is made.

== Blocks ==

Blocks can be used when you have something that repeats on a page, possibly with variations.

For example:

{{{
{block headline $title, $color = '#00f'}
	<h1 style="color:{$color}">
		{$title}
	</h1>
{/block}
}}}

Once declared, you can call the block, almost like any other tag, but using an "!" before the blockname:

	`{!headline "A blue headline"}`
	
	`{!headline "A red headline", "#f00"}`

Technically, blocks are simply php-functions, and therefore have all the features of a normal function declaration header in PHP - you separate the arguments with commas, both at declaration time, and when calling a block.

Note that the blockname is case-insensitive.

You can specify default values for arguments, e.g. $color = '#00f'.

You can place your block declaration in an external template, and {include} it from other templates - just be aware, that the include statement must precede the call; a block can not be called before it has been declared.

Also note that a block has it's own closed scope - it cannot see any template variables outside of itself, so if you have a variable in the template itself, that you need access to inside the block, you have to pass it as an argument.

Constants, on the other hand, are available globally.