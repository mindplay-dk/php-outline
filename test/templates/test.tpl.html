<h1>{$page_title}</h1>

<p>Testing »funny« characters</p>

<p>Testing context object - {if !isset($this)}we don't have {ignore}{$this}{/ignore}{else}we have {ignore}{$this}{/ignore} of class {#get_class($this)}{/if}.</p>

<p>Testing runtime context: {#get_class($_)} (note that you should consider the {ignore}{$_}{/ignore} variable private - any access to the underlying template runtime is provided through template commands)</p>

<p>This demonstrates a custom function call: <em>{testfunc value=time()}</em></p>

<p>Printing a constant defined in 'test_require.php': {#TEST_VALUE}</p>

<p>Applying a modifier to the same constant: {#TEST_VALUE|replace:'i':'iiiii'}</p>

{ignore}<h1>Testing the {block} command</h1>{/ignore}

{block:testBlock a='' b='this is the default value of $b'}
	<p>This is the output from the testBlock: '{$a}' and '{$b}'</p>
{/block}

{!testBlock a='this is the first value passed to testBlock'}
{!TESTBLOCK a='this is the first value passed to testBlock' b='this is the second value passed to testBlock'}

<h1>Testing variables and standard modifiers</h1>

<p>This value was assigned in the template function in 'test.php': "{$testvar}"</p>

<p>And the same variable with a native PHP function applied as modifier: "{$testvar|md5}"</p>

<p>This modifier uses a variable as one of it's arguments: "{$testvar|replace:'variable':'VARIABLE'}"</p>

<p>This demonstrates <span style="color:#{@testarray.RED}">lazy</span> <span style="color:#{@testarray.BLUE}">array</span> <span style="color:#{@testarray.GREEN|upper}">resolution</span> using ampersand.</p>

<textarea cols="80" rows="15">
default: {$empty_array|default:"the array is empty"}

strip: {set $test="spaces   will   be   stripped"}{$test|strip}

date: {#time()|date:"Y-m-d H:i:s"}

time: {#time()|time:"%c"}

html: {set $test = "<strong>bold text</strong>"}{$test|html}

url: {set $test = "url-encode this!"}http://www.google.com/search?{$test|url}

escape: {set $test = "'this will be escaped\nfor javascript'"}javascript:window.alert('{$test|escape}');
wed: {set $test = "the wed modifier prevents orphans in html"}{$test|wed|html}

lower: {set $test = 'LOWERCASE'}{$test|lower}

upper: {set $test = 'uppercase'}{$test|upper}

format: {set $test = 3.1415}{$test|format} | {set $test = 42000000}{$test|format:0}

br: {set $test = "this is\na test"}{$test|br|html}

chop: {set $test = "this is an example - the chop function shortens elaborate text at a given length"}{$test|chop:65}

</textarea>

{ignore}<h1>Testing the {capture} command</h1>{/ignore}

{capture $test}
This content was captured to the $test variable.
{/capture}

<p>Captured text: "{$test|trim}"</p>

{ignore}<h1>Testing the {set} command</h1>{/ignore}

{set $var='This string was assigned using the set command'}

<p>{$var}</p>

<h1>Testing the {ignore}{while}{/ignore} command</h1>

{set $i = 5}
<ul>
	{while $i > 0}
		<li>countdown {$i} ...</li>
		{set $i = $i - 1}
	{/while}
</ul>

{ignore}<h1>Testing variations of the {for} command</h1>{/ignore}

<p>Counting to ten: {for $var from 1 to 10}{$var}, {/for}...</p>

<p>Counting to a hundred by ten at a time: {for $var from 0 to 100 by 10}{$var}, {/for}...</p>

<p>Counting backwards from ten: {for $var from 10 to 1}{$var}, {/for}...</p>

<p>Using dynamic arguments: {for $var from date('Y') to date('Y')-9}{$var}, {/for}...</p>

{ignore}<h1>Testing the {foreach} command</h1>{/ignore}

{set $odd = false}

<ul>
	{foreach $testarray as $color => $code}
		<li><span style="color:{$code}">{$color}</span></li>
	{/foreach}
</ul>

{ignore}<h1>Testing {else} with {foreach}</h1>{/ignore}

{foreach $empty_array as $name => $value}
	<p>This will never execute</p>
{else}
	<p>This displays because the foreach'ed array was empty.</p>
{/foreach}

{ignore}<h1>Testing the {if} command</h1>{/ignore}

<p>
	{for $var from 1 to 10}
		{$var}
		{if $var < 3}
			is less than three
		{elseif $var > 8}
			is greater than eight
		{else}
			is between three and eight
		{/if}
		<br />
	{/for}
</p>

{ignore}<h1>Testing the {cycle} and {next} commands</h1>{/ignore}

<p>
	{for $var from 1 to 9}
		{cycle}
			one,
		{next}
			two,
		{next}
			three,
		{/cycle}
	{/for}
	...
</p>

{ignore}<h1>Testing the {modify} block command</h1>{/ignore}

{modify upper|br}
this
is a
test
{/modify}

{*
	these comments will go unseen
	these comments will go unseen
	these comments will go unseen
*}

<p>Contextual object's getTest() method returned: {$this->getTest()}</p>

<h1>Missing features</h1>
<p>The following list descibes features removed from Outline in version 2.0, and explains why:</p>
<ul>
  <li><strong>Caching:</strong> caching features have been removed. Caching is a generic feature - there are too many possible caching strategies for a template engine (or any other software component) to implement. It belongs in a framework, and most modern frameworks provide elaborate choices of caching media and strategies.</li>
  <li><strong>Inserts:</strong> with caching removed, the cache-specific {ignore}{insert}{/ignore} command has also been removed. Some (not all) frameworks provide an equivalent feature, which could easily be exposed to templates by implementing a framework-specific command. Frameworks that don't provide such a feature out of the box, could probably be extended to support such a feature.</li>
  <li><strong>Nesting:</strong> {ignore}nesting templates with the {require} command has been dropped, because different frameworks may use different conventions, caching schemes, etc. - the template engine now relies on a framework-specific {include} or {require} command.{/ignore}</li>
  <li><strong>Context:</strong> previous versions of Outline provided the $outline variable, giving a reference to the template engine, and providing means for engine wrappers to replace this context object. Outline 2 uses a different strategy - for one, it uses a single engine for any number of templates, rather than creating a new instance for every template. It also provides no runtime context, but instead encourages you to do so yourself - for example, by loading a template during a method-call to your own class, your are making available the {ignore}{$this}{/ignore} object reference - in an MVC environment, you can use this to effectively give templates access to protected members of a View class.</li>
  <li><strong>Includes:</strong> the {ignore}{include}, {require} and {display}{/ignore} commands have all been removed. These can very easily be implemented with framework-specific considerations, and have been removed simply to leave the command-names available for a framework-specific plugin to use.</li>
  <li><strong>OutlineHelper:</strong> this class was designed to support features now supported generically by plugins, in the form of plugin runtimes, and as such as no longer necessary.</li>
  <li><strong>OutlineTpl:</strong> this is gone for now - in the future, a stand-alone template engine may be built on top of Outline 2.0, for those who don't use a supported framework.</li>
</ul>

<h2>Page generated at {$testdate}</h2>
